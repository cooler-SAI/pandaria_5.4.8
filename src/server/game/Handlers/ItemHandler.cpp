/*
* This file is part of the Pandaria 5.4.8 Project. See THANKS file for Copyright information
*
* This program is free software; you can redistribute it and/or modify it
* under the terms of the GNU General Public License as published by the
* Free Software Foundation; either version 2 of the License, or (at your
* option) any later version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* You should have received a copy of the GNU General Public License along
* with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#include "Common.h"
#include "WorldPacket.h"
#include "WorldSession.h"
#include "Opcodes.h"
#include "Log.h"
#include "Chat.h"
#include "ObjectMgr.h"
#include "Player.h"
#include "Item.h"
#include "UpdateData.h"
#include "ObjectAccessor.h"
#include "SpellInfo.h"
#include "DB2Stores.h"
#include "GuildMgr.h"
#include "ServiceMgr.h"
#include <vector>

void WorldSession::HandleSplitItemOpcode(WorldPacket& recvData)
{
    //TC_LOG_DEBUG("network", "WORLD: CMSG_SPLIT_ITEM");
    uint8 srcBag, srcSlot, dstBag, dstSlot;
    uint32 count;

    recvData >> srcBag;
    recvData >> count;
    recvData >> dstBag >> srcSlot >> dstSlot;
    recvData.rfinish();

    //TC_LOG_DEBUG("STORAGE: receive srcbag = %u, srcslot = %u, dstbag = %u, dstslot = %u, count = %u", srcbag, srcslot, dstbag, dstslot, count);

    uint16 src = ((srcBag << 8) | srcSlot);
    uint16 dst = ((dstBag << 8) | dstSlot);

    if (src == dst)
        return;

    if (count == 0)
        return;                                             //check count - if zero it's fake packet

    if (!_player->IsValidPos(srcBag, srcSlot, true))
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    if (!_player->IsValidPos(dstBag, dstSlot, false))       // can be autostore pos
    {
        _player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }

    _player->SplitItem(src, dst, count);
}

void WorldSession::HandleSwapInvItemOpcode(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "WORLD: CMSG_SWAP_INV_ITEM");
    bool hasSrcSlot = false, HasDstSlot = false, HasSrcBag = false, HasDstBag = false;
    uint8 srcSlot = 0, dstSlot = 0, srcBag = 0, dstBag = 0, checkSrcSlot = 0, checkDstSlot = 0;

    recvData >> srcSlot >> dstSlot;

    uint8 size = recvData.ReadBits(2);
    if (size != 2)
        return;

    HasDstSlot = recvData.ReadBit();
    HasDstBag = recvData.ReadBit();
    hasSrcSlot = recvData.ReadBit();
    HasSrcBag = recvData.ReadBit();

    if (!HasDstSlot)
        recvData >> checkDstSlot;
    if (!HasDstBag)
        recvData >> dstBag;
    if (!hasSrcSlot)
        recvData >> checkSrcSlot;
    if (!HasSrcBag)
        recvData >> srcBag;

    if (srcSlot != checkSrcSlot || dstSlot != checkDstSlot)
        return;

    // prevent attempt swap same item to current position generated by client at special cheating sequence
    if (srcSlot == dstSlot)
        return;

    if (!_player->IsValidPos(srcBag, srcSlot, true))
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    if (!_player->IsValidPos(dstBag, dstSlot, true))
    {
        _player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }

    uint16 src = ((srcBag << 8) | srcSlot);
    uint16 dst = ((dstBag << 8) | dstSlot);

    _player->SwapItem(src, dst);
}

void WorldSession::HandleAutoEquipItemSlotOpcode(WorldPacket& recvData)
{
    uint8 slot = recvData.read<uint8>();
    ObjectGuid itemGuid;
    recvData.ReadGuidMask(itemGuid, 6, 3, 0);
    uint32 length = recvData.ReadBits(2);
    recvData.ReadGuidMask(itemGuid, 7);

    struct Unk14
    {
        uint8 Unk0;
        uint8 Unk1;
    };

    std::vector<Unk14> unk14;
    for (uint32 i = 0; i < length; ++i)
    {
        Unk14 u;
        u.Unk1 = recvData.ReadBit();
        u.Unk0 = recvData.ReadBit();
        unk14.push_back(u);
    }
    recvData.ReadGuidMask(itemGuid, 5, 2, 1, 4);
    recvData.ReadGuidBytes(itemGuid, 6, 3, 1, 7, 2, 0, 4, 5);

    for (auto&& itr : unk14)
    {
        if (itr.Unk1)
            itr.Unk1 = recvData.read<uint8>();
        if (itr.Unk0)
            itr.Unk0 = recvData.read<uint8>();
    }

    Item* item = GetPlayer()->GetItemByGuid(itemGuid);
    if (!item)
    {
        GetPlayer()->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL);
        return;
    }

    if (slot >= EQUIPMENT_SLOT_END)
    {
        GetPlayer()->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL);
        return;
    }

    uint16 dstpos = slot | (INVENTORY_SLOT_BAG_0 << 8);

    if (item->GetPos() == dstpos)
        return;

    GetPlayer()->SwapItem(item->GetPos(), dstpos);
}

void WorldSession::HandleSwapItem(WorldPacket& recvData)
{
    //TC_LOG_DEBUG("network", "WORLD: CMSG_SWAP_ITEM");
    bool hasSlot[2];
    bool hasBag[2];
    uint8 dstBag, dstSlot, srcBag, srcSlot;
    uint8 srcSlotAlt, srcBagAlt, dstSlotAlt, dstBagAlt;

    recvData >> srcSlotAlt >> srcBagAlt >> dstBagAlt >> dstSlotAlt;

    uint32 count = recvData.ReadBits(2);

    if (count != 2)
        return;

    for (uint8 i = 0; i < count; i++)
    {
        hasSlot[i] = !recvData.ReadBit();
        hasBag[i] = !recvData.ReadBit();
    }

    dstBag = hasBag[0] ? recvData.read<uint8>() : dstBagAlt;
    dstSlot = hasSlot[0] ? recvData.read<uint8>() : dstSlotAlt;
    srcBag = hasBag[1] ? recvData.read<uint8>() : srcBagAlt;
    srcSlot = hasSlot[1] ? recvData.read<uint8>() : srcSlotAlt;

    //TC_LOG_DEBUG("STORAGE: receive srcbag = %u, srcslot = %u, dstbag = %u, dstslot = %u", srcbag, srcslot, dstbag, dstslot);

    uint16 src = ((srcBag << 8) | srcSlot);
    uint16 dst = ((dstBag << 8) | dstSlot);

    // prevent attempt swap same item to current position generated by client at special checting sequence
    if (src == dst)
        return;

    if (!_player->IsValidPos(srcBag, srcSlot, true))
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    if (!_player->IsValidPos(dstBag, dstSlot, true))
    {
        _player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }

    _player->SwapItem(src, dst);
}

void WorldSession::HandleAutoEquipItemOpcode(WorldPacket& recvData)
{
    //TC_LOG_DEBUG("network", "WORLD: CMSG_AUTOEQUIP_ITEM");
    uint8 srcbag, srcslot;

    recvData >> srcslot >> srcbag;
    recvData.rfinish();
    //TC_LOG_DEBUG("STORAGE: receive srcbag = %u, srcslot = %u", srcbag, srcslot);

    Item* pSrcItem  = _player->GetItemByPos(srcbag, srcslot);
    if (!pSrcItem)
        return;                                             // only at cheat

    uint16 dest;
    InventoryResult msg = _player->CanEquipItem(NULL_SLOT, dest, pSrcItem, !pSrcItem->IsBag());
    if (msg != EQUIP_ERR_OK)
    {
        _player->SendEquipError(msg, pSrcItem, NULL);
        return;
    }

    uint16 src = pSrcItem->GetPos();
    if (dest == src)                                           // prevent equip in same slot, only at cheat
        return;

    Item* pDstItem = _player->GetItemByPos(dest);
    if (!pDstItem)                                         // empty slot, simple case
    {
        _player->RemoveItem(srcbag, srcslot, true);
        _player->EquipItem(dest, pSrcItem, true);
        _player->AutoUnequipOffhandIfNeed();
    }
    else                                                    // have currently equipped item, not simple case
    {
        uint8 dstbag = pDstItem->GetBagSlot();
        uint8 dstslot = pDstItem->GetSlot();

        msg = _player->CanUnequipItem(dest, !pSrcItem->IsBag());
        if (msg != EQUIP_ERR_OK)
        {
            _player->SendEquipError(msg, pDstItem, NULL);
            return;
        }

        // check dest->src move possibility
        ItemPosCountVec sSrc;
        uint16 eSrc = 0;
        if (_player->IsInventoryPos(src))
        {
            msg = _player->CanStoreItem(srcbag, srcslot, sSrc, pDstItem, true);
            if (msg != EQUIP_ERR_OK)
                msg = _player->CanStoreItem(srcbag, NULL_SLOT, sSrc, pDstItem, true);
            if (msg != EQUIP_ERR_OK)
                msg = _player->CanStoreItem(NULL_BAG, NULL_SLOT, sSrc, pDstItem, true);
        }
        else if (_player->IsBankPos(src))
        {
            msg = _player->CanBankItem(srcbag, srcslot, sSrc, pDstItem, true);
            if (msg != EQUIP_ERR_OK)
                msg = _player->CanBankItem(srcbag, NULL_SLOT, sSrc, pDstItem, true);
            if (msg != EQUIP_ERR_OK)
                msg = _player->CanBankItem(NULL_BAG, NULL_SLOT, sSrc, pDstItem, true);
        }
        else if (_player->IsEquipmentPos(src))
        {
            msg = _player->CanEquipItem(srcslot, eSrc, pDstItem, true);
            if (msg == EQUIP_ERR_OK)
                msg = _player->CanUnequipItem(eSrc, true);
        }

        if (msg != EQUIP_ERR_OK)
        {
            _player->SendEquipError(msg, pDstItem, pSrcItem);
            return;
        }

        // now do moves, remove...
        _player->RemoveItem(dstbag, dstslot, false);
        _player->RemoveItem(srcbag, srcslot, false);

        // add to dest
        _player->EquipItem(dest, pSrcItem, true);

        // add to src
        if (_player->IsInventoryPos(src))
            _player->StoreItem(sSrc, pDstItem, true);
        else if (_player->IsBankPos(src))
            _player->BankItem(sSrc, pDstItem, true);
        else if (_player->IsEquipmentPos(src))
            _player->EquipItem(eSrc, pDstItem, true);

        _player->AutoUnequipOffhandIfNeed();
    }
}

void WorldSession::HandleDestroyItemOpcode(WorldPacket& recvData)
{
    //TC_LOG_DEBUG("network", "WORLD: CMSG_DESTROY_ITEM");
    int32 count;
    int8 bag, slot;

    recvData >> count;
    recvData >> slot >> bag;
    //TC_LOG_DEBUG("STORAGE: receive bag = %u, slot = %u, count = %u", bag, slot, count);

    uint16 pos = (bag << 8) | slot;

    // prevent drop unequipable items (in combat, for example) and non-empty bags
    if (_player->IsEquipmentPos(pos) || _player->IsBagPos(pos))
    {
        InventoryResult msg = _player->CanUnequipItem(pos, false);
        if (msg != EQUIP_ERR_OK)
        {
            _player->SendEquipError(msg, _player->GetItemByPos(pos), NULL);
            return;
        }
    }

    Item* pItem  = _player->GetItemByPos(bag, slot);
    if (!pItem)
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
        return;
    }

    if (pItem->GetTemplate()->Flags & ITEM_PROTO_FLAG_INDESTRUCTIBLE)
    {
        _player->SendEquipError(EQUIP_ERR_DROP_BOUND_ITEM, NULL, NULL);
        return;
    }

    sServiceMgr->DeletedItemNotify(_player->GetGUIDLow(), pItem, DELETING_TYPE_BY_PLAYER);

    if (count)
    {
        uint32 i_count = count;
        _player->DestroyItemCount(pItem, i_count, true);
    }
    else
        _player->DestroyItem(bag, slot, true);
}

void WorldSession::HandleReadItem(WorldPacket& recvData)
{
    uint8 bag, slot;
    recvData >> bag >> slot;
    
    Item* pItem = _player->GetItemByPos(bag, slot);

    if (pItem && pItem->GetTemplate()->PageText)
    {
        WorldPacket data;

        InventoryResult msg = _player->CanUseItem(pItem);
        if (msg == EQUIP_ERR_OK)
        {
            data.Initialize(SMSG_READ_ITEM_RESULT_OK, 8);
            TC_LOG_INFO("network", "STORAGE: Item page sent");
        }
        else
        {
            data.Initialize(SMSG_READ_ITEM_RESULT_FAILED, 8);
            TC_LOG_INFO("network", "STORAGE: Unable to read item");
            _player->SendEquipError(msg, pItem, NULL);
        }
        data << pItem->GetGUID();
        SendPacket(&data);
    }
    else
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
}

void WorldSession::HandleSellItemOpcode(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "WORLD: Received CMSG_SELL_ITEM");

    ObjectGuid vendorGuid, itemGuid;
    uint32 count;

    recvData >> count;

    itemGuid[4] = recvData.ReadBit();
    itemGuid[3] = recvData.ReadBit();
    itemGuid[7] = recvData.ReadBit();
    vendorGuid[6] = recvData.ReadBit();
    vendorGuid[5] = recvData.ReadBit();
    vendorGuid[1] = recvData.ReadBit();
    itemGuid[5] = recvData.ReadBit();
    itemGuid[2] = recvData.ReadBit();
    itemGuid[1] = recvData.ReadBit();
    vendorGuid[2] = recvData.ReadBit();
    itemGuid[6] = recvData.ReadBit();
    vendorGuid[4] = recvData.ReadBit();
    vendorGuid[0] = recvData.ReadBit();
    vendorGuid[7] = recvData.ReadBit();
    vendorGuid[3] = recvData.ReadBit();
    itemGuid[0] = recvData.ReadBit();

    recvData.ReadByteSeq(vendorGuid[6]);
    recvData.ReadByteSeq(vendorGuid[3]);
    recvData.ReadByteSeq(vendorGuid[1]);
    recvData.ReadByteSeq(itemGuid[1]);
    recvData.ReadByteSeq(vendorGuid[2]);
    recvData.ReadByteSeq(itemGuid[7]);
    recvData.ReadByteSeq(itemGuid[5]);
    recvData.ReadByteSeq(vendorGuid[7]);
    recvData.ReadByteSeq(itemGuid[2]);
    recvData.ReadByteSeq(vendorGuid[0]);
    recvData.ReadByteSeq(vendorGuid[5]);
    recvData.ReadByteSeq(itemGuid[3]);
    recvData.ReadByteSeq(itemGuid[6]);
    recvData.ReadByteSeq(vendorGuid[4]);
    recvData.ReadByteSeq(itemGuid[4]);
    recvData.ReadByteSeq(itemGuid[0]);

    if (!itemGuid)
        return;

    Creature* creature = GetPlayer()->GetNPCIfCanInteractWith(vendorGuid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        TC_LOG_DEBUG("network", "WORLD: HandleSellItemOpcode - Unit (GUID: %u) not found or you can not interact with him.", uint32(GUID_LOPART(vendorGuid)));
        _player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, NULL, itemGuid);
        return;
    }

    switch (creature->GetEntry())
    {
        case 27914: // Ethereal Soul-Trader
            _player->SendSellError(SELL_ERR_CANT_SELL_TO_THIS_VENDOR, creature, itemGuid);
            return;
        default:
            break;
    }

    // remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

    Item* pItem = _player->GetItemByGuid(itemGuid);
    if (pItem)
    {
        // prevent sell not owner item
        if (_player->GetGUID() != pItem->GetOwnerGUID())
        {
            _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemGuid);
            return;
        }

        // prevent sell non empty bag by drag-and-drop at vendor's item list
        if (pItem->IsNotEmptyBag())
        {
            _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemGuid);
            return;
        }

        // prevent sell currently looted item
        if (_player->GetLootGUID() == pItem->GetGUID())
        {
            _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemGuid);
            return;
        }

        // prevent selling item for sellprice when the item is still refundable
        // this probably happens when right clicking a refundable item, the client sends both
        // CMSG_SELL_ITEM and CMSG_REFUND_ITEM (unverified)
        if (pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE))
            return; // Therefore, no feedback to client

        // special case at auto sell (sell all)
        if (count == 0)
            count = pItem->GetCount();
        else
        {
            // prevent sell more items that exist in stack (possible only not from client)
            if (count > pItem->GetCount())
            {
                _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemGuid);
                return;
            }
        }

        if (pItem->IsBroken())
        {
            _player->SendSellError(SELL_ERR_CANT_SELL_BROKEN_ITEM, creature, itemGuid);
            return;
        }

        ItemTemplate const* pProto = pItem->GetTemplate();
        if (pProto)
        {
            if (pProto->SellPrice > 0)
            {
                uint32 money = pProto->SellPrice * count;
                if (count < pItem->GetCount())               // need split items
                {
                    Item* pNewItem = pItem->CloneItem(count, _player);
                    if (!pNewItem)
                    {
                        TC_LOG_ERROR("network", "WORLD: HandleSellItemOpcode - could not create clone of item %u; count = %u", pItem->GetEntry(), count);
                        _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemGuid);
                        return;
                    }

                    pItem->SetCount(pItem->GetCount() - count);
                    _player->ItemRemovedQuestCheck(pItem->GetEntry(), count);
                    if (_player->IsInWorld())
                        pItem->SendUpdateToPlayer(_player);
                    pItem->SetState(ITEM_CHANGED, _player);

                    _player->AddItemToBuyBackSlot(pNewItem);
                    if (_player->IsInWorld())
                        pNewItem->SendUpdateToPlayer(_player);
                }
                else
                {
                    _player->ItemRemovedQuestCheck(pItem->GetEntry(), pItem->GetCount());
                    _player->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
                    pItem->RemoveFromUpdateQueueOf(_player);
                    _player->AddItemToBuyBackSlot(pItem);
                }
                _player->ModifyMoney(money);
                _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_MONEY_FROM_VENDORS, money);
            }
            else
                _player->SendSellError(SELL_ERR_CANT_SELL_ITEM, creature, itemGuid);
            return;
        }
    }
    _player->SendSellError(SELL_ERR_CANT_FIND_ITEM, creature, itemGuid);
    return;
}

void WorldSession::HandleBuybackItem(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "WORLD: Received CMSG_BUYBACK_ITEM");

    ObjectGuid vendorGuid;
    uint32 slot;

    recvData >> slot;

    vendorGuid[2] = recvData.ReadBit();
    vendorGuid[3] = recvData.ReadBit();
    vendorGuid[0] = recvData.ReadBit();
    vendorGuid[4] = recvData.ReadBit();
    vendorGuid[1] = recvData.ReadBit();
    vendorGuid[7] = recvData.ReadBit();
    vendorGuid[5] = recvData.ReadBit();
    vendorGuid[6] = recvData.ReadBit();

    recvData.ReadByteSeq(vendorGuid[0]);
    recvData.ReadByteSeq(vendorGuid[6]);
    recvData.ReadByteSeq(vendorGuid[1]);
    recvData.ReadByteSeq(vendorGuid[7]);
    recvData.ReadByteSeq(vendorGuid[5]);
    recvData.ReadByteSeq(vendorGuid[2]);
    recvData.ReadByteSeq(vendorGuid[3]);
    recvData.ReadByteSeq(vendorGuid[4]);

    Creature* creature = GetPlayer()->GetNPCIfCanInteractWith(vendorGuid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        TC_LOG_DEBUG("network", "WORLD: HandleBuybackItem - Unit (GUID: %u) not found or you can not interact with him.", uint32(GUID_LOPART(vendorGuid)));
        _player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, NULL, 0);
        return;
    }

    // remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

    Item* pItem = _player->GetItemFromBuyBackSlot(slot);
    if (pItem)
    {
        uint32 price = _player->GetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + slot - BUYBACK_SLOT_START);
        if (!_player->HasEnoughMoney(uint64(price)))
        {
            _player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, pItem->GetEntry(), 0);
            return;
        }

        ItemPosCountVec dest;
        InventoryResult msg = _player->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
        if (msg == EQUIP_ERR_OK)
        {
            _player->ModifyMoney(-(int32)price);
            _player->RemoveItemFromBuyBackSlot(slot, false);
            _player->ItemAddedQuestCheck(pItem->GetEntry(), pItem->GetCount());
            _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, pItem->GetEntry(), pItem->GetCount());

            _player->StoreItem(dest, pItem, true);
        }
        else
            _player->SendEquipError(msg, pItem, NULL);
        return;
    }
    else
        _player->SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, 0, 0);

    GetPlayer()->SetSaveTimer(1);
}

void WorldSession::HandleBuyItemInSlotOpcode(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "WORLD: Received CMSG_BUY_ITEM_IN_SLOT");
    uint64 vendorguid, bagguid;
    uint32 item, slot, count;
    uint8 bagslot;

    recvData >> vendorguid >> item  >> slot >> bagguid >> bagslot >> count;

    // client expects count starting at 1, and we send vendorslot+1 to client already
    if (slot > 0)
        --slot;
    else
        return;                                             // cheating

    uint8 bag = NULL_BAG;                                   // init for case invalid bagGUID
    Item* bagItem = NULL;
    // find bag slot by bag guid
    if (bagguid == _player->GetGUID())
        bag = INVENTORY_SLOT_BAG_0;
    else
        bagItem = _player->GetItemByGuid(bagguid);

    if (bagItem && bagItem->IsBag())
        bag = bagItem->GetSlot();

    // bag not found, cheating?
    if (bag == NULL_BAG)
        return;

    GetPlayer()->BuyItemFromVendorSlot(vendorguid, slot, item, count, bag, bagslot);
}

void WorldSession::HandleBuyItemOpcode(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "WORLD: Received CMSG_BUY_ITEM");

    ObjectGuid vendorGuid, bagGuid;
    uint32 item, slot, count, bagSlot;
    uint8 itemType; // 1 = item, 2 = currency

    recvData >> bagSlot >> count >> item >> slot;

    vendorGuid[6] = recvData.ReadBit();
    bagGuid[6] = recvData.ReadBit();
    bagGuid[4] = recvData.ReadBit();
    vendorGuid[4] = recvData.ReadBit();
    itemType = recvData.ReadBits(2);
    vendorGuid[0] = recvData.ReadBit();
    vendorGuid[3] = recvData.ReadBit();
    bagGuid[3] = recvData.ReadBit();
    vendorGuid[7] = recvData.ReadBit();
    vendorGuid[5] = recvData.ReadBit();
    bagGuid[2] = recvData.ReadBit();
    vendorGuid[1] = recvData.ReadBit();
    bagGuid[7] = recvData.ReadBit();
    vendorGuid[2] = recvData.ReadBit();
    bagGuid[1] = recvData.ReadBit();
    bagGuid[0] = recvData.ReadBit();
    bagGuid[5] = recvData.ReadBit();

    recvData.ReadByteSeq(vendorGuid[5]);
    recvData.ReadByteSeq(vendorGuid[0]);
    recvData.ReadByteSeq(bagGuid[3]);
    recvData.ReadByteSeq(bagGuid[1]);
    recvData.ReadByteSeq(bagGuid[6]);
    recvData.ReadByteSeq(vendorGuid[2]);
    recvData.ReadByteSeq(vendorGuid[7]);
    recvData.ReadByteSeq(vendorGuid[6]);
    recvData.ReadByteSeq(bagGuid[0]);
    recvData.ReadByteSeq(bagGuid[5]);
    recvData.ReadByteSeq(vendorGuid[4]);
    recvData.ReadByteSeq(bagGuid[2]);
    recvData.ReadByteSeq(vendorGuid[3]);
    recvData.ReadByteSeq(bagGuid[7]);
    recvData.ReadByteSeq(vendorGuid[1]);
    recvData.ReadByteSeq(bagGuid[4]);

    // client expects count starting at 1, and we send vendorslot+1 to client already
    if (slot > 0)
        --slot;
    else
        return; // cheating

    if (itemType == ITEM_VENDOR_TYPE_ITEM)
    {
        Item* bagItem = _player->GetItemByGuid(bagGuid);

        uint8 bag = NULL_BAG;
        if (bagItem && bagItem->IsBag())
            bag = bagItem->GetSlot();
        else if (bagGuid == GetPlayer()->GetGUID()) // The client sends the player guid when trying to store an item in the default backpack
            bag = INVENTORY_SLOT_BAG_0;

        GetPlayer()->BuyItemFromVendorSlot(vendorGuid, slot, item, count, bag, bagSlot);
    }
    else if (itemType == ITEM_VENDOR_TYPE_CURRENCY)
        GetPlayer()->BuyCurrencyFromVendorSlot(vendorGuid, slot, item, count);
    else
        TC_LOG_DEBUG("network", "WORLD: received wrong itemType (%u) in HandleBuyItemOpcode", itemType);

    GetPlayer()->SetSaveTimer(1);
}

void WorldSession::HandleListInventoryOpcode(WorldPacket& recvData)
{
    ObjectGuid guid;

    guid[6] = recvData.ReadBit();
    guid[7] = recvData.ReadBit();
    guid[3] = recvData.ReadBit();
    guid[1] = recvData.ReadBit();
    guid[2] = recvData.ReadBit();
    guid[0] = recvData.ReadBit();
    guid[4] = recvData.ReadBit();
    guid[5] = recvData.ReadBit();

    recvData.ReadByteSeq(guid[0]);
    recvData.ReadByteSeq(guid[7]);
    recvData.ReadByteSeq(guid[1]);
    recvData.ReadByteSeq(guid[6]);
    recvData.ReadByteSeq(guid[4]);
    recvData.ReadByteSeq(guid[3]);
    recvData.ReadByteSeq(guid[5]);
    recvData.ReadByteSeq(guid[2]);

    if (!GetPlayer()->IsAlive())
        return;

    TC_LOG_DEBUG("network", "WORLD: Recvd CMSG_LIST_INVENTORY");

    SendListInventory(guid);
}

void WorldSession::SendListInventory(uint64 vendorGuid, uint32 vendorEntry)
{
    TC_LOG_DEBUG("network", "WORLD: Sent SMSG_LIST_INVENTORY");

    Creature* vendor = GetPlayer()->GetNPCIfCanInteractWith(vendorGuid, UNIT_NPC_FLAG_VENDOR);
    if (!vendor)
    {
        TC_LOG_DEBUG("network", "WORLD: SendListInventory - Unit (GUID: %u) not found or you can not interact with him.", uint32(GUID_LOPART(vendorGuid)));
        _player->SendSellError(SELL_ERR_CANT_FIND_VENDOR, NULL, 0);
        return;
    }

    // remove fake death
    if (GetPlayer()->HasUnitState(UNIT_STATE_DIED))
        GetPlayer()->RemoveAurasByType(SPELL_AURA_FEIGN_DEATH);

    // Stop the npc if moving
    if (vendor->HasUnitState(UNIT_STATE_MOVING))
        vendor->StopMoving();

    SetCurrentVendor(vendorEntry);

    VendorItemData const* vendorItems = vendorEntry ? sObjectMgr->GetNpcVendorItemList(vendorEntry) : vendor->GetVendorItems();
    uint32 rawItemCount = vendorItems ? vendorItems->GetItemCount() : 0;

    //if (rawItemCount > 300),
    // rawItemCount = 300; // client cap but uint8 max value is 255

    ByteBuffer itemsData(32 * rawItemCount);    

    bool hasExtendedCost[MAX_VENDOR_ITEMS];

    const float discountMod = _player->GetReputationPriceDiscount(vendor);
    uint8 count = 0;

    Guild* guild = GetPlayer()->GetGuild();

    for (uint32 slot = 0; slot < rawItemCount; ++slot)
    {
        VendorItem const* vendorItem = vendorItems->GetItem(slot);
        if (!vendorItem)
            continue;

        if (vendorItem->Type == ITEM_VENDOR_TYPE_ITEM)
        {
            ItemTemplate const* itemTemplate = sObjectMgr->GetItemTemplate(vendorItem->item);
            if (!itemTemplate)
                continue;

            int32 leftInStock = !vendorItem->maxcount ? -1 : vendor->GetVendorItemCurrentCount(vendorItem);
            if (!_player->IsGameMaster()) // ignore conditions if GM on
            {
                // Respect allowed class
                if (!(itemTemplate->AllowableClass & _player->GetClassMask()) && itemTemplate->Bonding == BIND_ON_ACQUIRE)
                    continue;

                // Only display items in vendor lists for the team the player is on
                if ((itemTemplate->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY && _player->GetTeam() == ALLIANCE) ||
                    (itemTemplate->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY && _player->GetTeam() == HORDE))
                    continue;

                // Items sold out are not displayed in list
                if (leftInStock == 0)
                    continue;
            }

            ConditionList conditions = sConditionMgr->GetConditionsForNpcVendorEvent(vendor->GetEntry(), vendorItem->item);
            if (!sConditionMgr->IsObjectMeetToConditions(_player, vendor, conditions))
            {
                TC_LOG_DEBUG("condition", "SendListInventory: conditions not met for creature entry %u item %u", vendor->GetEntry(), vendorItem->item);
                continue;
            }

            auto& rewards = sGuildMgr->GetGuildRewards();
            auto it = std::find_if(rewards.begin(), rewards.end(), [=](GuildReward const& r) { return r.Entry == vendorItem->item; });
            if (it != rewards.end())
            {
                if (!guild)
                    continue;

                GuildReward const& reward = *it;
                if (GetPlayer()->GetReputationRank(GUILD_REPUTATION_ID) < reward.Standing)
                    continue;
                bool meet = true;
                for (auto&& id : reward.Achievements)
                {
                    if (AchievementEntry const* achiev = sAchievementStore.LookupEntry(id))
                    {
                        if ((achiev->RequiredFaction == ACHIEVEMENT_FACTION_HORDE    && GetPlayer()->GetTeam() != HORDE) ||
                            (achiev->RequiredFaction == ACHIEVEMENT_FACTION_ALLIANCE && GetPlayer()->GetTeam() != ALLIANCE))
                            continue;
                        if (!guild->HasAchieved(id))
                        {
                            meet = false;
                            break;
                        }
                    }
                }
                if (!meet)
                    continue;
            }

            int32 price = vendorItem->IsGoldRequired(itemTemplate) ? uint32(floor(itemTemplate->BuyPrice * discountMod)) : 0;

            if (int32 priceMod = _player->GetTotalAuraModifier(SPELL_AURA_MOD_VENDOR_ITEMS_PRICES))
                price -= CalculatePct(price, priceMod);

            itemsData << int32(leftInStock);
            itemsData << uint32(price);
            itemsData << uint32(vendorItem->Type); // 1 is items, 2 is currency
            itemsData << int32(itemTemplate->MaxDurability ? itemTemplate->MaxDurability : -1);
            itemsData << uint32(itemTemplate->DisplayInfoID);
            itemsData << uint32(itemTemplate->BuyCount);
            itemsData << uint32(vendorItem->item);

            if (vendorItem->ExtendedCost)
            {
                hasExtendedCost[count] = true;
                itemsData << uint32(vendorItem->ExtendedCost);
            }
            else
                hasExtendedCost[count] = false;

            itemsData << uint32(GetUpgradeId(itemTemplate->ItemId));
            itemsData << uint32(slot + 1); // client expects counting to start at 1

            if (++count >= MAX_VENDOR_ITEMS)
                break;
        }
        else if (vendorItem->Type == ITEM_VENDOR_TYPE_CURRENCY)
        {
            CurrencyTypesEntry const* currencyTemplate = sCurrencyTypesStore.LookupEntry(vendorItem->item);
            if (!currencyTemplate)
                continue;

            if (!vendorItem->ExtendedCost)
                continue; // there's no price defined for currencies, only extendedcost is used

            itemsData << int32(-1); // left in stock
            itemsData << uint32(0); // price, only seen currency types that have Extended cost
            itemsData << uint32(vendorItem->Type); // 1 is items, 2 is currency
            itemsData << int32(0);
            itemsData << uint32(0); // displayId
            itemsData << uint32(vendorItem->maxcount); // buy count
            itemsData << uint32(vendorItem->item);

            hasExtendedCost[count] = true;
            itemsData << uint32(vendorItem->ExtendedCost);

            itemsData << uint32(0);
            itemsData << uint32(slot + 1); // client expects counting to start at 1

            if (++count >= MAX_VENDOR_ITEMS)
                break;
        }
    }

    ObjectGuid guid = vendorGuid;

    WorldPacket data(SMSG_LIST_INVENTORY, 12 + itemsData.size());
    data.WriteBit(guid[5]);
    data.WriteBit(guid[7]);
    data.WriteBit(guid[1]);
    data.WriteBit(guid[3]);
    data.WriteBit(guid[6]);
    data.WriteBits(count, 18); // item count

    for (uint32 i = 0; i < count; i++)
    {
        data.WriteBit(0); // Do Not Filter On Vendor
        data.WriteBit(!hasExtendedCost[i]);
        data.WriteBit(1); // Has Condition
    }

    data.WriteBit(guid[4]);
    data.WriteBit(guid[0]);
    data.WriteBit(guid[2]);

    data << uint8(0); // Reason

    data.append(itemsData);

    data.WriteByteSeq(guid[3]);
    data.WriteByteSeq(guid[7]);
    data.WriteByteSeq(guid[0]);
    data.WriteByteSeq(guid[6]);
    data.WriteByteSeq(guid[2]);
    data.WriteByteSeq(guid[1]);
    data.WriteByteSeq(guid[4]);
    data.WriteByteSeq(guid[5]);

    SendPacket(&data);
}

void WorldSession::HandleAutoStoreBagItemOpcode(WorldPacket& recvData)
{
    //TC_LOG_DEBUG("network", "WORLD: CMSG_AUTOSTORE_BAG_ITEM");
    uint8 srcBag, srcSlot, dstBag;

    recvData >> srcSlot >> srcBag >> dstBag;
    recvData.rfinish();

    //TC_LOG_DEBUG("STORAGE: receive srcbag = %u, srcslot = %u, dstbag = %u", srcbag, srcslot, dstbag);

    Item* pItem = _player->GetItemByPos(srcBag, srcSlot);
    if (!pItem)
        return;

    if (!_player->IsValidPos(dstBag, NULL_SLOT, false))      // can be autostore pos
    {
        _player->SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return;
    }

    uint16 src = pItem->GetPos();

    // check unequip potability for equipped items and bank bags
    if (_player->IsEquipmentPos (src) || _player->IsBagPos (src))
    {
        InventoryResult msg = _player->CanUnequipItem(src, !_player->IsBagPos (src));
        if (msg != EQUIP_ERR_OK)
        {
            _player->SendEquipError(msg, pItem, NULL);
            return;
        }
    }

    ItemPosCountVec dest;
    InventoryResult msg = _player->CanStoreItem(dstBag, NULL_SLOT, dest, pItem, false);
    if (msg != EQUIP_ERR_OK)
    {
        _player->SendEquipError(msg, pItem, NULL);
        return;
    }

    // no-op: placed in same slot
    if (dest.size() == 1 && dest[0].pos == src)
    {
        // just remove grey item state
        _player->SendEquipError(EQUIP_ERR_INTERNAL_BAG_ERROR, pItem, NULL);
        return;
    }

    _player->RemoveItem(srcBag, srcSlot, true);
    _player->StoreItem(dest, pItem, true);
}

void WorldSession::HandleBuyBankSlotOpcode(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "WORLD: CMSG_BUY_BANK_SLOT");

    ObjectGuid guid;

    guid[7] = recvData.ReadBit();
    guid[6] = recvData.ReadBit();
    guid[1] = recvData.ReadBit();
    guid[3] = recvData.ReadBit();
    guid[2] = recvData.ReadBit();
    guid[0] = recvData.ReadBit();
    guid[4] = recvData.ReadBit();
    guid[5] = recvData.ReadBit();

    recvData.ReadByteSeq(guid[3]);
    recvData.ReadByteSeq(guid[5]);
    recvData.ReadByteSeq(guid[1]);
    recvData.ReadByteSeq(guid[6]);
    recvData.ReadByteSeq(guid[7]);
    recvData.ReadByteSeq(guid[2]);
    recvData.ReadByteSeq(guid[0]);
    recvData.ReadByteSeq(guid[4]);

    // cheating protection
    /* not critical if "cheated", and check skip allow by slots in bank windows open by .bank command.
    Creature* creature = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_BANKER);
    if (!creature)
    {
        TC_LOG_DEBUG("WORLD: HandleBuyBankSlotOpcode - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(guid)));
        return;
    }
    */

    uint32 slot = _player->GetBankBagSlotCount();

    // next slot
    ++slot;

    TC_LOG_INFO("network", "PLAYER: Buy bank bag slot, slot number = %u", slot);

    BankBagSlotPricesEntry const* slotEntry = sBankBagSlotPricesStore.LookupEntry(slot);
    if (!slotEntry)
        return;

    uint32 price = slotEntry->price;
    if (!_player->HasEnoughMoney(uint64(price)))
    {
        _player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
        return;
    }

    _player->SetBankBagSlotCount(slot);
    _player->ModifyMoney(-int64(price));

    _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BUY_BANK_SLOT);
}

void WorldSession::HandleAutoBankItemOpcode(WorldPacket& recvPacket)
{
    TC_LOG_DEBUG("network", "WORLD: CMSG_AUTOBANK_ITEM");
    uint8 srcBag, srcSlot;

    recvPacket >> srcSlot >> srcBag;
    recvPacket.rfinish();

    TC_LOG_DEBUG("network", "STORAGE: receive srcbag = %u, srcslot = %u", srcBag, srcSlot);

    Item* pItem = _player->GetItemByPos(srcBag, srcSlot);
    if (!pItem)
        return;

    ItemPosCountVec dest;
    InventoryResult msg = _player->CanBankItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
    if (msg != EQUIP_ERR_OK)
    {
        _player->SendEquipError(msg, pItem, NULL);
        return;
    }

    if (dest.size() == 1 && dest[0].pos == pItem->GetPos())
    {
        _player->SendEquipError(EQUIP_ERR_CANT_SWAP, pItem, NULL);
        return;
    }

    _player->RemoveItem(srcBag, srcSlot, true);
    _player->ItemRemovedQuestCheck(pItem->GetEntry(), pItem->GetCount());
    _player->BankItem(dest, pItem, true);
}

void WorldSession::HandleAutoStoreBankItemOpcode(WorldPacket& recvPacket)
{
    TC_LOG_DEBUG("network", "WORLD: CMSG_AUTOSTORE_BANK_ITEM");
    uint8 srcBag, srcSlot;

    recvPacket >> srcSlot >> srcBag;
    TC_LOG_DEBUG("network", "STORAGE: receive srcbag = %u, srcslot = %u", srcBag, srcSlot);

    Item* pItem = _player->GetItemByPos(srcBag, srcSlot);
    if (!pItem)
        return;

    if (_player->IsBankPos(srcBag, srcSlot))                 // moving from bank to inventory
    {
        ItemPosCountVec dest;
        InventoryResult msg = _player->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            _player->SendEquipError(msg, pItem, NULL);
            return;
        }

        _player->RemoveItem(srcBag, srcSlot, true);
        if (Item const* storedItem = _player->StoreItem(dest, pItem, true))
            _player->ItemAddedQuestCheck(storedItem->GetEntry(), storedItem->GetCount());
    }
    else                                                    // moving from inventory to bank
    {
        ItemPosCountVec dest;
        InventoryResult msg = _player->CanBankItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            _player->SendEquipError(msg, pItem, NULL);
            return;
        }

        _player->RemoveItem(srcBag, srcSlot, true);
        _player->BankItem(dest, pItem, true);
    }
}

void WorldSession::SendEnchantmentLog(uint64 target, uint64 caster, uint64 item, uint32 itemId, uint32 enchantId, uint8 slot)
{
    ObjectGuid casterGUID = caster;
    ObjectGuid itemGUID = item;
    ObjectGuid targetGUID = target;

    WorldPacket data(SMSG_ENCHANTMENT_LOG);
    data << uint32(enchantId);
    data << uint32(slot);
    data << uint32(itemId);

    data.WriteBit(itemGUID[6]);
    data.WriteBit(itemGUID[7]);
    data.WriteBit(targetGUID[6]);
    data.WriteBit(targetGUID[4]);
    data.WriteBit(itemGUID[5]);
    data.WriteBit(casterGUID[7]);
    data.WriteBit(casterGUID[2]);
    data.WriteBit(casterGUID[3]);
    data.WriteBit(itemGUID[4]);
    data.WriteBit(itemGUID[3]);
    data.WriteBit(casterGUID[6]);
    data.WriteBit(targetGUID[1]);
    data.WriteBit(itemGUID[2]);
    data.WriteBit(targetGUID[5]);
    data.WriteBit(casterGUID[4]);
    data.WriteBit(targetGUID[0]);
    data.WriteBit(casterGUID[1]);
    data.WriteBit(itemGUID[0]);
    data.WriteBit(targetGUID[3]);
    data.WriteBit(targetGUID[7]);
    data.WriteBit(casterGUID[5]);
    data.WriteBit(casterGUID[0]);
    data.WriteBit(targetGUID[2]);
    data.WriteBit(itemGUID[1]);

    data.FlushBits();

    data.WriteByteSeq(itemGUID[0]);
    data.WriteByteSeq(targetGUID[2]);
    data.WriteByteSeq(casterGUID[7]);
    data.WriteByteSeq(itemGUID[1]);
    data.WriteByteSeq(targetGUID[4]);
    data.WriteByteSeq(casterGUID[5]);
    data.WriteByteSeq(itemGUID[4]);
    data.WriteByteSeq(casterGUID[2]);
    data.WriteByteSeq(targetGUID[6]);
    data.WriteByteSeq(targetGUID[0]);
    data.WriteByteSeq(casterGUID[0]);
    data.WriteByteSeq(casterGUID[4]);
    data.WriteByteSeq(itemGUID[3]);
    data.WriteByteSeq(targetGUID[5]);
    data.WriteByteSeq(casterGUID[1]);
    data.WriteByteSeq(targetGUID[3]);
    data.WriteByteSeq(targetGUID[7]);
    data.WriteByteSeq(itemGUID[7]);
    data.WriteByteSeq(casterGUID[3]);
    data.WriteByteSeq(itemGUID[6]);
    data.WriteByteSeq(itemGUID[2]);
    data.WriteByteSeq(itemGUID[5]);
    data.WriteByteSeq(casterGUID[6]);
    data.WriteByteSeq(targetGUID[1]);

    GetPlayer()->SendMessageToSet(&data, true);
}

void WorldSession::SendItemEnchantTimeUpdate(ObjectGuid Playerguid, ObjectGuid Itemguid, uint32 slot, uint32 Duration)
{
    WorldPacket data(SMSG_ITEM_ENCHANT_TIME_UPDATE, 8 + 8 + 4 + 4);

    data.WriteBit(Itemguid[4]);
    data.WriteBit(Itemguid[0]);
    data.WriteBit(Playerguid[3]);
    data.WriteBit(Itemguid[3]);
    data.WriteBit(Playerguid[2]);
    data.WriteBit(Playerguid[6]);
    data.WriteBit(Playerguid[7]);
    data.WriteBit(Itemguid[1]);
    data.WriteBit(Playerguid[4]);
    data.WriteBit(Itemguid[6]);
    data.WriteBit(Itemguid[5]);
    data.WriteBit(Playerguid[0]);
    data.WriteBit(Itemguid[2]);
    data.WriteBit(Playerguid[5]);
    data.WriteBit(Playerguid[1]);
    data.WriteBit(Itemguid[7]);

    data.FlushBits();

    data << uint32(slot);
    data.WriteByteSeq(Playerguid[4]);
    data.WriteByteSeq(Playerguid[2]);
    data.WriteByteSeq(Itemguid[5]);
    data.WriteByteSeq(Itemguid[4]);
    data.WriteByteSeq(Playerguid[6]);
    data.WriteByteSeq(Itemguid[1]);
    data.WriteByteSeq(Playerguid[0]);
    data.WriteByteSeq(Playerguid[1]);
    data.WriteByteSeq(Itemguid[6]);
    data.WriteByteSeq(Itemguid[2]);
    data.WriteByteSeq(Playerguid[7]);
    data.WriteByteSeq(Itemguid[0]);
    data.WriteByteSeq(Itemguid[3]);
    data.WriteByteSeq(Itemguid[7]);
    data.WriteByteSeq(Playerguid[3]);
    data.WriteByteSeq(Playerguid[5]);
    data << uint32(Duration);

    SendPacket(&data);
}

void WorldSession::HandleWrapItemOpcode(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "Received opcode CMSG_WRAP_ITEM");

    // Still wrong, just shutting up the analyzer
    uint8 gift_bag = 0, gift_slot = 0, item_bag = 0, item_slot = 0;

    uint8 size = recvData.ReadBits(2);
    if (size != 2)
        return;

    bool has_gift_slot = !recvData.ReadBit();
    bool has_gift_bag  = !recvData.ReadBit();
    bool has_item_slot = !recvData.ReadBit();
    bool has_item_bag  = !recvData.ReadBit();

    if (has_gift_slot)
        recvData >> gift_slot;                 // paper
    if (has_gift_bag)
        recvData >> gift_bag;
    if (has_item_slot)
        recvData >> item_slot;                 // item
    if (has_item_bag)
        recvData >> item_bag;

    TC_LOG_DEBUG("network", "WRAP: receive gift_bag = %u, gift_slot = %u, item_bag = %u, item_slot = %u", gift_bag, gift_slot, item_bag, item_slot);

    Item* gift = _player->GetItemByPos(gift_bag, gift_slot);
    if (!gift)
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, gift, NULL);
        return;
    }

    if (!(gift->GetTemplate()->Flags & ITEM_PROTO_FLAG_WRAPPER)) // cheating: non-wrapper wrapper
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, gift, NULL);
        return;
    }

    Item* item = _player->GetItemByPos(item_bag, item_slot);

    if (!item)
    {
        _player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, item, NULL);
        return;
    }

    if (item == gift)                                          // not possable with pacjket from real client
    {
        _player->SendEquipError(EQUIP_ERR_CANT_WRAP_WRAPPED, item, NULL);
        return;
    }

    if (item->IsEquipped())
    {
        _player->SendEquipError(EQUIP_ERR_CANT_WRAP_EQUIPPED, item, NULL);
        return;
    }

    if (item->GetUInt64Value(ITEM_FIELD_GIFT_CREATOR))        // HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAGS_WRAPPED);
    {
        _player->SendEquipError(EQUIP_ERR_CANT_WRAP_WRAPPED, item, NULL);
        return;
    }

    if (item->IsBag())
    {
        _player->SendEquipError(EQUIP_ERR_CANT_WRAP_BAGS, item, NULL);
        return;
    }

    if (item->IsSoulBound() || item->IsBoundByEnchant())
    {
        _player->SendEquipError(EQUIP_ERR_CANT_WRAP_BOUND, item, NULL);
        return;
    }

    if (item->GetMaxStackCount() != 1)
    {
        _player->SendEquipError(EQUIP_ERR_CANT_WRAP_STACKABLE, item, NULL);
        return;
    }

    // maybe not correct check  (it is better than nothing)
    if (item->GetTemplate()->MaxCount > 0)
    {
        _player->SendEquipError(EQUIP_ERR_CANT_WRAP_UNIQUE, item, NULL);
        return;
    }

    CharacterDatabaseTransaction trans = CharacterDatabase.BeginTransaction();

    CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_GIFT);
    stmt->setUInt32(0, GUID_LOPART(item->GetOwnerGUID()));
    stmt->setUInt32(1, item->GetGUIDLow());
    stmt->setUInt32(2, item->GetEntry());
    stmt->setUInt32(3, item->GetUInt32Value(ITEM_FIELD_DYNAMIC_FLAGS));
    trans->Append(stmt);

    item->SetEntry(gift->GetEntry());

    switch (item->GetEntry())
    {
        case 5042:  item->SetEntry(5043); break;
        case 5048:  item->SetEntry(5044); break;
        case 17303: item->SetEntry(17302); break;
        case 17304: item->SetEntry(17305); break;
        case 17307: item->SetEntry(17308); break;
        case 21830: item->SetEntry(21831); break;
    }
    item->SetUInt64Value(ITEM_FIELD_GIFT_CREATOR, _player->GetGUID());
    item->SetUInt32Value(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_WRAPPED);
    item->SetState(ITEM_CHANGED, _player);

    if (item->GetState() == ITEM_NEW)                          // save new item, to have alway for `character_gifts` record in `item_instance`
    {
        // after save it will be impossible to remove the item from the queue
        item->RemoveFromUpdateQueueOf(_player);
        item->SaveToDB(trans);                                   // item gave inventory record unchanged and can be save standalone
    }
    CharacterDatabase.CommitTransaction(trans);

    uint32 count = 1;
    _player->DestroyItemCount(gift, count, true);
}

void WorldSession::HandleSocketOpcode(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "WORLD: CMSG_SOCKET_GEMS");

    ObjectGuid item_guid;
    ObjectGuid gem_guids[MAX_GEM_SOCKETS];

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][4] = recvData.ReadBit();
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][0] = recvData.ReadBit();
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][6] = recvData.ReadBit();
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][2] = recvData.ReadBit();
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][1] = recvData.ReadBit();
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][7] = recvData.ReadBit();
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][3] = recvData.ReadBit();
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        gem_guids[i][5] = recvData.ReadBit();

    item_guid[5] = recvData.ReadBit();
    item_guid[0] = recvData.ReadBit();
    item_guid[6] = recvData.ReadBit();
    item_guid[2] = recvData.ReadBit();
    item_guid[3] = recvData.ReadBit();
    item_guid[4] = recvData.ReadBit();
    item_guid[7] = recvData.ReadBit();
    item_guid[1] = recvData.ReadBit();

    recvData.ReadByteSeq(item_guid[7]);
    recvData.ReadByteSeq(item_guid[2]);
    recvData.ReadByteSeq(item_guid[6]);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][6]);
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][4]);
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][3]);
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][2]);
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][0]);
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][1]);
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][7]);
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        recvData.ReadByteSeq(gem_guids[i][5]);

    recvData.ReadByteSeq(item_guid[4]);
    recvData.ReadByteSeq(item_guid[3]);
    recvData.ReadByteSeq(item_guid[1]);
    recvData.ReadByteSeq(item_guid[5]);
    recvData.ReadByteSeq(item_guid[0]);

    if (!item_guid)
        return;

    //cheat -> tried to socket same gem multiple times
    if ((gem_guids[0] && (gem_guids[0] == gem_guids[1] || gem_guids[0] == gem_guids[2])) ||
        (gem_guids[1] && (gem_guids[1] == gem_guids[2])))
        return;

    Item* itemTarget = _player->GetItemByGuid(item_guid);
    if (!itemTarget)                                         //missing item to socket
        return;

    ItemTemplate const* itemProto = itemTarget->GetTemplate();
    if (!itemProto)
        return;

    //this slot is excepted when applying / removing meta gem bonus
    uint8 slot = itemTarget->IsEquipped() ? itemTarget->GetSlot() : uint8(NULL_SLOT);

    Item* Gems[MAX_GEM_SOCKETS];
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
        Gems[i] = gem_guids[i] ? _player->GetItemByGuid(gem_guids[i]) : NULL;

    GemPropertiesEntry const* GemProps[MAX_GEM_SOCKETS];
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)                //get geminfo from dbc storage
        GemProps[i] = (Gems[i]) ? sGemPropertiesStore.LookupEntry(Gems[i]->GetTemplate()->GemProperties) : NULL;

    int32 firstPrismatic = 0;
    while (firstPrismatic < MAX_GEM_SOCKETS && itemProto->Socket[firstPrismatic].Color)
        ++firstPrismatic;

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)                //check for hack maybe
    {
        if (!GemProps[i])
            continue;

        // tried to put gem in socket where no socket exists (take care about prismatic sockets)
        if (!itemProto->Socket[i].Color)
        {
            // no prismatic socket
            if (!itemTarget->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT))
                return;
            // Check socket
            if (i != firstPrismatic)
                return;
        }

        // tried to put normal gem in meta socket
        if (itemProto->Socket[i].Color == SOCKET_COLOR_META && GemProps[i]->color != SOCKET_COLOR_META)
            return;

        // tried to put meta gem in normal socket
        if (itemProto->Socket[i].Color != SOCKET_COLOR_META && GemProps[i]->color == SOCKET_COLOR_META)
            return;

        // tried to put normal gem in cogwheel socket
        if (itemProto->Socket[i].Color == SOCKET_COLOR_COGWHEEL && GemProps[i]->color != SOCKET_COLOR_COGWHEEL)
            return;

        // tried to put cogwheel gem in normal socket
        if (itemProto->Socket[i].Color != SOCKET_COLOR_COGWHEEL && GemProps[i]->color == SOCKET_COLOR_COGWHEEL)
            return;
    }

    uint32 GemEnchants[MAX_GEM_SOCKETS];
    uint32 OldEnchants[MAX_GEM_SOCKETS];
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)                //get new and old enchantments
    {
        GemEnchants[i] = (GemProps[i]) ? GemProps[i]->spellitemenchantement : 0;
        OldEnchants[i] = itemTarget->GetEnchantmentId(EnchantmentSlot(SOCK_ENCHANTMENT_SLOT+i));
    }

    // check unique-equipped conditions
    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (!Gems[i])
            continue;

        // continue check for case when attempt add 2 similar unique equipped gems in one item.
        ItemTemplate const* iGemProto = Gems[i]->GetTemplate();

        // unique item (for new and already placed bit removed enchantments
        if (iGemProto->Flags & ITEM_PROTO_FLAG_UNIQUE_EQUIPPED)
        {
            for (int j = 0; j < MAX_GEM_SOCKETS; ++j)
            {
                if (i == j)                                    // skip self
                    continue;

                if (Gems[j])
                {
                    if (iGemProto->ItemId == Gems[j]->GetEntry())
                    {
                        _player->SendEquipError(EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget, NULL);
                        return;
                    }
                }
                else if (OldEnchants[j])
                {
                    if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(OldEnchants[j]))
                    {
                        if (iGemProto->ItemId == enchantEntry->GemID)
                        {
                            _player->SendEquipError(EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget, NULL);
                            return;
                        }
                    }
                }
            }
        }

        // unique limit type item
        int32 limit_newcount = 0;
        if (iGemProto->ItemLimitCategory)
        {
            if (ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(iGemProto->ItemLimitCategory))
            {
                // NOTE: limitEntry->mode is not checked because if item has limit then it is applied in equip case
                for (int j = 0; j < MAX_GEM_SOCKETS; ++j)
                {
                    if (Gems[j])
                    {
                        // new gem
                        if (iGemProto->ItemLimitCategory == Gems[j]->GetTemplate()->ItemLimitCategory)
                            ++limit_newcount;
                    }
                    else if (OldEnchants[j])
                    {
                        // existing gem
                        if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(OldEnchants[j]))
                            if (ItemTemplate const* jProto = sObjectMgr->GetItemTemplate(enchantEntry->GemID))
                                if (iGemProto->ItemLimitCategory == jProto->ItemLimitCategory)
                                    ++limit_newcount;
                    }
                }

                if (limit_newcount > 0 && uint32(limit_newcount) > limitEntry->maxCount)
                {
                    _player->SendEquipError(EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget, NULL);
                    return;
                }
            }
        }

        // for equipped item check all equipment for duplicate equipped gems
        if (itemTarget->IsEquipped())
        {
            if (InventoryResult res = _player->CanEquipUniqueItem(Gems[i], slot, std::max(limit_newcount, 0)))
            {
                _player->SendEquipError(res, itemTarget, NULL);
                return;
            }
        }
    }

    bool SocketBonusActivated = itemTarget->GemsFitSockets();    //save state of socketbonus
    _player->ToggleMetaGemsActive(slot, false);             //turn off all metagems (except for the target item)

    //if a meta gem is being equipped, all information has to be written to the item before testing if the conditions for the gem are met

    //remove ALL enchants
    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++enchant_slot)
        _player->ApplyEnchantment(itemTarget, EnchantmentSlot(enchant_slot), false);

    for (int i = 0; i < MAX_GEM_SOCKETS; ++i)
    {
        if (GemEnchants[i])
        {
            itemTarget->SetEnchantment(EnchantmentSlot(SOCK_ENCHANTMENT_SLOT+i), GemEnchants[i], 0, 0, _player->GetGUID());
            if (Item* guidItem = _player->GetItemByGuid(gem_guids[i]))
            {
                uint32 gemCount = 1;
                _player->DestroyItemCount(guidItem, gemCount, true);
            }
        }
    }

    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+MAX_GEM_SOCKETS; ++enchant_slot)
        _player->ApplyEnchantment(itemTarget, EnchantmentSlot(enchant_slot), true);

    bool SocketBonusToBeActivated = itemTarget->GemsFitSockets();//current socketbonus state
    if (SocketBonusActivated ^ SocketBonusToBeActivated)     //if there was a change...
    {
        _player->ApplyEnchantment(itemTarget, BONUS_ENCHANTMENT_SLOT, false);
        itemTarget->SetEnchantment(BONUS_ENCHANTMENT_SLOT, (SocketBonusToBeActivated ? itemTarget->GetTemplate()->socketBonus : 0), 0, 0, _player->GetGUID());
        _player->ApplyEnchantment(itemTarget, BONUS_ENCHANTMENT_SLOT, true);
        //it is not displayed, client has an inbuilt system to determine if the bonus is activated
    }

    _player->ToggleMetaGemsActive(slot, true);              //turn on all metagems (except for target item)

    itemTarget->ClearSoulboundTradeable(_player);           // clear tradeable flag

    itemTarget->SendUpdateSockets();
}

void WorldSession::HandleCancelTempEnchantmentOpcode(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "WORLD: CMSG_CANCEL_TEMP_ENCHANTMENT");

    uint32 slot;

    recvData >> slot;

    // apply only to equipped item
    if (!Player::IsEquipmentPos(INVENTORY_SLOT_BAG_0, slot))
        return;

    Item* item = GetPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);

    if (!item)
        return;

    if (!item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
        return;

    GetPlayer()->ApplyEnchantment(item, TEMP_ENCHANTMENT_SLOT, false);
    item->ClearEnchantment(TEMP_ENCHANTMENT_SLOT);
}

void WorldSession::HandleItemRefundInfoRequest(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "WORLD: CMSG_ITEM_REFUND_INFO");

    ObjectGuid guid;
    
    guid[1] = recvData.ReadBit();
    guid[0] = recvData.ReadBit();
    guid[3] = recvData.ReadBit();
    guid[2] = recvData.ReadBit();
    guid[7] = recvData.ReadBit();
    guid[4] = recvData.ReadBit();
    guid[5] = recvData.ReadBit();
    guid[6] = recvData.ReadBit();
    
    recvData.ReadByteSeq(guid[3]);
    recvData.ReadByteSeq(guid[7]);
    recvData.ReadByteSeq(guid[5]);
    recvData.ReadByteSeq(guid[1]);
    recvData.ReadByteSeq(guid[0]);
    recvData.ReadByteSeq(guid[6]);
    recvData.ReadByteSeq(guid[4]);
    recvData.ReadByteSeq(guid[2]);

    Item* item = _player->GetItemByGuid(guid);
    if (!item)
    {
        TC_LOG_DEBUG("network", "Item refund: item not found!");
        return;
    }

    GetPlayer()->SendRefundInfo(item);
}

void WorldSession::HandleItemRefund(WorldPacket &recvData)
{
    TC_LOG_DEBUG("network", "WORLD: CMSG_ITEM_REFUND");
    ObjectGuid guid;
    recvData.ReadGuidMask(guid, 2, 4, 1, 6, 3, 0, 5, 7);
    recvData.ReadGuidBytes(guid, 3, 5, 6, 2, 7, 0, 1, 4);

    Item* item = _player->GetItemByGuid(guid);
    if (!item)
    {
        TC_LOG_DEBUG("network", "Item refund: item not found!");
        return;
    }

    GetPlayer()->RefundItem(item);
}

/**
 * Handles the packet sent by the client when requesting information about item text.
 *
 * This function is called when player clicks on item which has some flag set
 */
void WorldSession::HandleItemTextQuery(WorldPacket& recvData)
{
    uint64 itemGuid;
    recvData >> itemGuid;

    TC_LOG_DEBUG("network", "CMSG_ITEM_TEXT_QUERY item guid: %u", GUID_LOPART(itemGuid));

    WorldPacket data(SMSG_ITEM_TEXT_QUERY_RESPONSE, 14);    // guess size

    if (Item* item = _player->GetItemByGuid(itemGuid))
    {
        data << uint8(0);                                       // has text
        data << uint64(itemGuid);                               // item guid
        data << item->GetText();
    }
    else
    {
        data << uint8(1);                                       // no text
    }

    SendPacket(&data);
}

void WorldSession::HandleTransmogrifyItems(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "WORLD: Received CMSG_TRANSMOGRIFY_ITEMS");
    Player* player = GetPlayer();

    // Read data
    uint32 count;
    ObjectGuid npcGuid;

    npcGuid[5] = recvData.ReadBit();
    npcGuid[6] = recvData.ReadBit();
    npcGuid[1] = recvData.ReadBit();
    npcGuid[2] = recvData.ReadBit();
    npcGuid[3] = recvData.ReadBit();
    npcGuid[4] = recvData.ReadBit();
    count = recvData.ReadBits(21);

    std::vector<ObjectGuid>itemGuids(count, ObjectGuid(0));
    std::vector<uint32>newEntries(count, 0);
    std::vector<uint32>slots(count, 0);
    std::vector<bool>HasItemBonus(count, false);
    std::vector<bool>HasModifications(count, false);

    for (uint8 i = 0; i < count; ++i)
    {
        HasItemBonus[i] = recvData.ReadBit();
        HasModifications[i] = recvData.ReadBit();
    }

    if (count >= EQUIPMENT_SLOT_END)
    {
        TC_LOG_DEBUG("network", "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) sent a wrong count (%u) when transmogrifying items.", player->GetGUIDLow(), player->GetName().c_str(), count);
        recvData.rfinish();
        return;
    }

    npcGuid[0] = recvData.ReadBit();
    npcGuid[7] = recvData.ReadBit();

    for (uint8 i = 0; i < count; ++i)
    {
        if (HasModifications[i])
        {
            itemGuids[i][5] = recvData.ReadBit();
            itemGuids[i][6] = recvData.ReadBit();
            itemGuids[i][1] = recvData.ReadBit();
            itemGuids[i][3] = recvData.ReadBit();
            itemGuids[i][0] = recvData.ReadBit();
            itemGuids[i][4] = recvData.ReadBit();
            itemGuids[i][7] = recvData.ReadBit();
            itemGuids[i][2] = recvData.ReadBit();
        }

        if (HasItemBonus[i])
        {
            itemGuids[i][4] = recvData.ReadBit();
            itemGuids[i][1] = recvData.ReadBit();
            itemGuids[i][0] = recvData.ReadBit();
            itemGuids[i][6] = recvData.ReadBit();
            itemGuids[i][5] = recvData.ReadBit();
            itemGuids[i][2] = recvData.ReadBit();
            itemGuids[i][7] = recvData.ReadBit();
            itemGuids[i][3] = recvData.ReadBit();
        }
    }

    for (uint8 i = 0; i < count; ++i)
    {
        recvData >> slots[i];
        recvData >> newEntries[i];
    }

    recvData.ReadByteSeq(npcGuid[5]);
    recvData.ReadByteSeq(npcGuid[0]);
    recvData.ReadByteSeq(npcGuid[1]);
    recvData.ReadByteSeq(npcGuid[2]);
    recvData.ReadByteSeq(npcGuid[3]);
    recvData.ReadByteSeq(npcGuid[4]);
    recvData.ReadByteSeq(npcGuid[6]);
    recvData.ReadByteSeq(npcGuid[7]);

    for (uint8 i = 0; i < count; ++i)
    {
        if (HasModifications[i])
        {
            recvData.ReadByteSeq(itemGuids[i][2]);
            recvData.ReadByteSeq(itemGuids[i][5]);
            recvData.ReadByteSeq(itemGuids[i][4]);
            recvData.ReadByteSeq(itemGuids[i][3]);
            recvData.ReadByteSeq(itemGuids[i][6]);
            recvData.ReadByteSeq(itemGuids[i][0]);
            recvData.ReadByteSeq(itemGuids[i][7]);
            recvData.ReadByteSeq(itemGuids[i][1]);
        }

        if (HasItemBonus[i])
        {
            recvData.ReadByteSeq(itemGuids[i][7]);
            recvData.ReadByteSeq(itemGuids[i][1]);
            recvData.ReadByteSeq(itemGuids[i][6]);
            recvData.ReadByteSeq(itemGuids[i][5]);
            recvData.ReadByteSeq(itemGuids[i][4]);
            recvData.ReadByteSeq(itemGuids[i][3]);
            recvData.ReadByteSeq(itemGuids[i][0]);
            recvData.ReadByteSeq(itemGuids[i][2]);
        }
    }

    if (!player->GetNPCIfCanInteractWith(npcGuid, UNIT_NPC_FLAG_TRANSMOGRIFIER))
    {
        TC_LOG_DEBUG("network", "WORLD: HandleTransmogrifyItems - Unit (GUID: %u) not found or player can't interact with it.", GUID_LOPART(npcGuid));
        return;
    }

    int32 cost = 0;
    for (uint8 i = 0; i < count; ++i)
    {
        // slot of the transmogrified item
        if (slots[i] >= EQUIPMENT_SLOT_END)
        {
            TC_LOG_DEBUG("network", "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify an item (lowguid: %u) with a wrong slot (%u) when transmogrifying items.", player->GetGUIDLow(), player->GetName().c_str(), GUID_LOPART(itemGuids[i]), slots[i]);
            return;
        }

        // entry of the transmogrifier item, if it's not 0
        if (newEntries[i])
        {
            ItemTemplate const* proto = sObjectMgr->GetItemTemplate(newEntries[i]);
            if (!proto)
            {
                TC_LOG_DEBUG("network", "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify to an invalid item (entry: %u).", player->GetGUIDLow(), player->GetName().c_str(), newEntries[i]);
                return;
            }
        }

        uint8 slot;
        VoidStorageItem* vsItem = nullptr;
        Item* itemTransmogrifier = nullptr;
        // guid of the transmogrifier item, if it's not 0
        if (itemGuids[i])
        {
            itemTransmogrifier = player->GetItemByGuid(itemGuids[i]);
            vsItem = player->GetVoidStorageItem(itemGuids[i], slot);

            if (!itemTransmogrifier && !vsItem)
            {
                TC_LOG_DEBUG("network", "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify with an invalid item (lowguid: %u).", player->GetGUIDLow(), player->GetName().c_str(), GUID_LOPART(itemGuids[i]));
                return;
            }

            if (itemTransmogrifier && itemTransmogrifier->GetEntry() != newEntries[i])
                return;

            if (vsItem && vsItem->ItemEntry != newEntries[i])
                return;
        }

        // transmogrified item
        Item* itemTransmogrified = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slots[i]);
        if (!itemTransmogrified)
        {
            TC_LOG_DEBUG("network", "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) tried to transmogrify an invalid item in a valid slot (slot: %u).", player->GetGUIDLow(), player->GetName().c_str(), slots[i]);
            return;
        }

        // uint16 tempDest;
        //// has to be able to equip item transmogrified item
        //if (!player->CanEquipItem(slots[i], tempDest, itemTransmogrified, true, true))
        //{
        //    TC_LOG_DEBUG("network", "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) can't equip the item to be transmogrified (slot: %u, entry: %u).", player->GetGUIDLow(), player->GetName().c_str(), slots[i], itemTransmogrified->GetEntry());
        //    return;
        //}
        //
        //// has to be able to equip item transmogrifier item
        //if (!player->CanEquipItem(slots[i], tempDest, itemTransmogrifier, true, true))
        //{
        //    TC_LOG_DEBUG("network", "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) can't equip the transmogrifier item (slot: %u, entry: %u).", player->GetGUIDLow(), player->GetName().c_str(), slots[i], itemTransmogrifier->GetEntry());
        //    return;
        //}

        if (!newEntries[i]) // reset look
        {
            itemTransmogrified->RemoveDynamicModifier(ITEM_MODIFIER_INDEX_TRANSMOGRIFICATION, player);
            player->SetVisibleItemSlot(slots[i], itemTransmogrified);
        }
        else
        {
            if (!sObjectMgr->CanTransmogrifyItemWithItem(itemTransmogrified->GetTemplate(), itemTransmogrifier ? itemTransmogrifier->GetTemplate() : sObjectMgr->GetItemTemplate(vsItem->ItemEntry)))
            {
                TC_LOG_DEBUG("network", "WORLD: HandleTransmogrifyItems - Player (GUID: %u, name: %s) failed CanTransmogrifyItemWithItem (%u with %u).", player->GetGUIDLow(), player->GetName().c_str(), itemTransmogrified->GetEntry(), itemTransmogrifier->GetEntry());
                return;
            }

            // All okay, proceed
            itemTransmogrified->SetDynamicModifier(ITEM_MODIFIER_INDEX_TRANSMOGRIFICATION, newEntries[i], player);

            player->SetVisibleItemSlot(slots[i], itemTransmogrified);

            itemTransmogrified->SetOwnerGUID(player->GetGUID());
            itemTransmogrified->SetNotRefundable(player);
            itemTransmogrified->ClearSoulboundTradeable(player);

            if (itemTransmogrifier && (itemTransmogrifier->GetTemplate()->Bonding == BIND_ON_EQUIP || itemTransmogrifier->GetTemplate()->Bonding == BIND_ON_USE))
                itemTransmogrifier->SetBinding(true);

            if (itemTransmogrifier)
            {
                itemTransmogrifier->SetOwnerGUID(player->GetGUID());
                itemTransmogrifier->SetNotRefundable(player);
                itemTransmogrifier->ClearSoulboundTradeable(player);
            }

            itemTransmogrified->SetState(ITEM_CHANGED, player);

            cost += itemTransmogrified->GetSpecialPrice();
        }
    }

    // trusting the client, if it got here it has to have enough money
    // ... unless client was modified
    if (cost) // 0 cost if reverting look
        player->ModifyMoney(-cost);
}

void WorldSession::HandleReforgeItemOpcode(WorldPacket& recvData)
{
    uint32 slot, reforgeEntry;
    ObjectGuid guid;
    uint32 bag;
    Player* player = GetPlayer();

    recvData >> reforgeEntry >> bag >> slot;

    recvData.ReadGuidMask(guid, 1, 0, 5, 3, 4, 2, 7, 6);
    recvData.ReadGuidBytes(guid, 4, 6, 3, 1, 2, 7, 0, 5);

    if (!player->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_REFORGER))
    {
        TC_LOG_INFO("network", "WORLD: HandleReforgeItemOpcode - Unit (GUID: %u) not found or player can't interact with it.", GUID_LOPART(guid));
        SendReforgeResult(false);
        return;
    }

    Item* item = player->GetItemByPos(bag, slot);
    if (!item)
    {
        TC_LOG_INFO("network", "WORLD: HandleReforgeItemOpcode - Player (Guid: %u Name: %s) tried to reforge an invalid/non-existant item.", player->GetGUIDLow(), player->GetName().c_str());
        SendReforgeResult(false);
        return;
    }

    if (!reforgeEntry)
    {
        // Reset the item
        if (item->IsEquipped() && !item->IsBroken())
            player->ApplyReforgeEnchantment(item, false);

        item->RemoveDynamicModifier(ITEM_MODIFIER_INDEX_REFORGE, player);
        SendReforgeResult(true);
        return;
    }

    ItemReforgeEntry const* stats = sItemReforgeStore.LookupEntry(reforgeEntry);
    if (!stats)
    {
        TC_LOG_INFO("network", "WORLD: HandleReforgeItemOpcode - Player (Guid: %u Name: %s) tried to reforge an item with invalid reforge entry (%u).", player->GetGUIDLow(), player->GetName().c_str(), reforgeEntry);
        SendReforgeResult(false);
        return;
    }

    if (item->GetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, ITEM_MODIFIER_INDEX_REFORGE))
    {
        SendReforgeResult(false);
        return;
    }

    if (!item->GetReforgableStat(ItemModType(stats->SourceStat)) || item->GetReforgableStat(ItemModType(stats->FinalStat))) // Cheating, you cant reforge to a stat that the item already has, nor reforge from a stat that the item does not have
    {
        SendReforgeResult(false);
        return;
    }

    if (!player->HasEnoughMoney(uint64(item->GetSpecialPrice()))) // cheating
    {
        SendReforgeResult(false);
        return;
    }

    item->ClearSoulboundTradeable(player);

    player->ModifyMoney(-int64(item->GetSpecialPrice()));

    item->SetDynamicModifier(ITEM_MODIFIER_INDEX_REFORGE, reforgeEntry, player);

    SendReforgeResult(true);

    if (item->IsEquipped() && !item->IsBroken())
        player->ApplyReforgeEnchantment(item, true);
}

void WorldSession::SendReforgeResult(bool success)
{
    WorldPacket data(SMSG_REFORGE_RESULT, 1);
    data.WriteBit(success);
    data.FlushBits();
    SendPacket(&data);
}

void WorldSession::SendItemExpirePurchaseRefund(ObjectGuid itemGuid)
{
    WorldPacket data(SMSG_ITEM_EXPIRE_PURCHASE_REFUND, 8);

    data.WriteBit(itemGuid[7]);
    data.WriteBit(itemGuid[4]);
    data.WriteBit(itemGuid[2]);
    data.WriteBit(itemGuid[6]);
    data.WriteBit(itemGuid[5]);
    data.WriteBit(itemGuid[3]);
    data.WriteBit(itemGuid[1]);
    data.WriteBit(itemGuid[0]);

    data.WriteByteSeq(itemGuid[4]);
    data.WriteByteSeq(itemGuid[0]);
    data.WriteByteSeq(itemGuid[6]);
    data.WriteByteSeq(itemGuid[7]);
    data.WriteByteSeq(itemGuid[1]);
    data.WriteByteSeq(itemGuid[2]);
    data.WriteByteSeq(itemGuid[3]);
    data.WriteByteSeq(itemGuid[5]);

    SendPacket(&data);
}

void WorldSession::SendItemUpgradeResult(bool success)
{
    WorldPacket data(SMSG_ITEM_UPGRADE_RESULT, 1);
    data.WriteBit(success);
    data.FlushBits();

    SendPacket(&data);
}

void WorldSession::HandleUpgradeItemOpcode(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "Received opcode CMSG_UPGRADE_ITEM");
    ObjectGuid npcGuid;
    ObjectGuid itemGuid;
    Player* player = GetPlayer();
    uint32 item_bag = 0, item_slot = 0, upgradeEntry = 0;

    recvData >> item_slot >> item_bag >> upgradeEntry;

    itemGuid[5] = recvData.ReadBit();
    npcGuid[6] = recvData.ReadBit();
    itemGuid[6] = recvData.ReadBit();
    itemGuid[0] = recvData.ReadBit();
    itemGuid[1] = recvData.ReadBit();
    npcGuid[4] = recvData.ReadBit();
    npcGuid[1] = recvData.ReadBit();
    npcGuid[7] = recvData.ReadBit();
    itemGuid[7] = recvData.ReadBit();
    itemGuid[2] = recvData.ReadBit();
    itemGuid[3] = recvData.ReadBit();
    npcGuid[0] = recvData.ReadBit();
    npcGuid[2] = recvData.ReadBit();
    npcGuid[5] = recvData.ReadBit();
    itemGuid[4] = recvData.ReadBit();
    npcGuid[3] = recvData.ReadBit();

    recvData.ReadByteSeq(itemGuid[7]);
    recvData.ReadByteSeq(npcGuid[6]);
    recvData.ReadByteSeq(itemGuid[6]);
    recvData.ReadByteSeq(npcGuid[3]);
    recvData.ReadByteSeq(npcGuid[2]);
    recvData.ReadByteSeq(itemGuid[5]);
    recvData.ReadByteSeq(npcGuid[1]);
    recvData.ReadByteSeq(itemGuid[1]);
    recvData.ReadByteSeq(npcGuid[0]);
    recvData.ReadByteSeq(itemGuid[2]);
    recvData.ReadByteSeq(itemGuid[0]);
    recvData.ReadByteSeq(npcGuid[4]);
    recvData.ReadByteSeq(npcGuid[5]);
    recvData.ReadByteSeq(itemGuid[3]);
    recvData.ReadByteSeq(npcGuid[7]);
    recvData.ReadByteSeq(itemGuid[4]);

    if (!player->GetNPCIfCanInteractWithFlag2(npcGuid, UNIT_NPC_FLAG2_ITEM_UPGRADE))
    {
        TC_LOG_DEBUG("network", "WORLD: HandleUpgradeItemOpcode - Unit (GUID: %u) not found or player can't interact with it.", GUID_LOPART(npcGuid));
        SendItemUpgradeResult(false);
        return;
    }

    Item* item = player->GetItemByGuid(itemGuid);
    if (!item)
    {
        TC_LOG_DEBUG("network", "WORLD: HandleUpgradeItemOpcode - Item (GUID: %u) not found.", GUID_LOPART(itemGuid));
        SendItemUpgradeResult(false);
        return;
    }

    // Check if item guid is the same as item related to bag and slot
    if (Item* tempItem = player->GetItemByPos(item_bag, item_slot))
    {
        if (item != tempItem)
        {
            TC_LOG_DEBUG("network", "WORLD: HandleUpgradeItemOpcode - Item (GUID: %u) not found.", GUID_LOPART(itemGuid));
            SendItemUpgradeResult(false);
            return;
        }
    }
    else
    {
        TC_LOG_DEBUG("network", "WORLD: HandleUpgradeItemOpcode - Item (GUID: %u) not found.", GUID_LOPART(itemGuid));
        SendItemUpgradeResult(false);
        return;
    }

    ItemUpgradeEntry const* itemUpEntry = sItemUpgradeStore.LookupEntry(upgradeEntry);
    if (!itemUpEntry)
    {
        TC_LOG_DEBUG("network", "WORLD: HandleUpgradeItemOpcode - ItemUpgradeEntry (%u) not found.", upgradeEntry);
        SendItemUpgradeResult(false);
        return;
    }

    // Check if player has enough currency
    if (player->GetCurrency(itemUpEntry->CurrencyID, false) < itemUpEntry->CurrencyCost)
    {
        TC_LOG_DEBUG("network", "WORLD: HandleUpgradeItemOpcode - Player has not enougth currency (ID: %u, Cost: %u) not found.", itemUpEntry->CurrencyID, itemUpEntry->CurrencyCost);
        SendItemUpgradeResult(false);
        return;
    }

    uint32 actualUpgrade = item->GetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, ITEM_MODIFIER_INDEX_UPGRADE);
    if (actualUpgrade != itemUpEntry->PrevItemUpgradeID)
    {
        TC_LOG_DEBUG("network", "WORLD: HandleUpgradeItemOpcode - ItemUpgradeEntry (%u) is not related to this ItemUpgradePath (%u).", itemUpEntry->ID, actualUpgrade);
        SendItemUpgradeResult(false);
        return;
    }

    if (item->IsEquipped() && !item->IsBroken())
    {
        player->_ApplyItemBonuses(item, item->GetSlot(), false);
        player->ApplyItemEquipSpell(item, false);
        player->ApplyEnchantment(item, false);
    }

    item->SetDynamicModifier(ITEM_MODIFIER_INDEX_UPGRADE, itemUpEntry->ID, player);
    item->OverrideItemLevel(player->GetItemLevel(item));

    if (item->IsEquipped() && !item->IsBroken())
    {
        player->_ApplyItemBonuses(item, item->GetSlot(), true);
        player->ApplyItemEquipSpell(item, true);
        player->ApplyEnchantment(item, true);
    }

    item->ClearSoulboundTradeable(player);

    // Remove currency cost.
    SendItemUpgradeResult(true);

    int32 currencyPointsCost = itemUpEntry->CurrencyCost;

    player->ModifyCurrency(itemUpEntry->CurrencyID, -currencyPointsCost, false, true, true);
}

void WorldSession::SendItemDb2Reply(uint32 entry, ByteBuffer& buffer)
{
    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(entry);
    if (!proto)
        return;

    buffer << uint32(entry);
    buffer << uint32(proto->Class);
    buffer << uint32(proto->SubClass);
    buffer << int32(proto->SoundOverrideSubclass);
    buffer << uint32(proto->Material);
    buffer << uint32(proto->DisplayInfoID);
    buffer << uint32(proto->InventoryType);
    buffer << uint32(proto->Sheath);
}

void WorldSession::SendItemSparseDb2Reply(uint32 entry, ByteBuffer& buffer)
{
    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(entry);
    if (!proto)
        return;

    int32 locale = GetSessionDbLocaleIndex();

    buffer << uint32(entry);
    buffer << uint32(proto->Quality);
    buffer << uint32(proto->Flags);
    buffer << uint32(proto->Flags2);
    buffer << uint32(proto->Flags3);
    buffer << float(proto->Unk430_1);
    buffer << float(proto->Unk430_2);
    buffer << uint32(proto->BuyCount);
    buffer << int32(proto->BuyPrice);
    buffer << uint32(proto->SellPrice);
    buffer << uint32(proto->InventoryType);
    buffer << int32(proto->AllowableClass);
    buffer << int32(proto->AllowableRace);
    buffer << uint32(proto->ItemLevel);
    buffer << uint32(proto->RequiredLevel);
    buffer << uint32(proto->RequiredSkill);
    buffer << uint32(proto->RequiredSkillRank);
    buffer << uint32(proto->RequiredSpell);
    buffer << uint32(proto->RequiredHonorRank);
    buffer << uint32(proto->RequiredCityRank);
    buffer << uint32(proto->RequiredReputationFaction);
    buffer << uint32(proto->RequiredReputationRank);
    buffer << int32(proto->MaxCount);
    buffer << int32(proto->Stackable);
    buffer << uint32(proto->ContainerSlots);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_STATS; ++x)
        buffer << uint32(proto->ItemStat[x].ItemStatType);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_STATS; ++x)
        buffer << int32(proto->ItemStat[x].ItemStatValue);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_STATS; ++x)
        buffer << int32(proto->ItemStat[x].ItemStatAllocation);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_STATS; ++x)
        buffer << int32(proto->ItemStat[x].ItemStatSocketCostMultiplier);

    buffer << uint32(proto->ScalingStatDistribution);
    buffer << uint32(proto->DamageType);
    buffer << uint32(proto->Delay);
    buffer << float(proto->RangedModRange);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buffer << int32(proto->Spells[x].SpellId);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buffer << uint32(proto->Spells[x].SpellTrigger);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buffer << int32(proto->Spells[x].SpellCharges);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buffer << int32(proto->Spells[x].SpellCooldown);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buffer << uint32(proto->Spells[x].SpellCategory);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SPELLS; ++x)
        buffer << int32(proto->Spells[x].SpellCategoryCooldown);

    buffer << uint32(proto->Bonding);

    // item name
    std::string name = proto->Name1;
    if (locale >= 0)
        if (ItemLocale const* localeData = sObjectMgr->GetItemLocale(entry))
            ObjectMgr::GetLocaleStringOld(localeData->Name, locale, name);

    buffer << uint16(name.length());
    if (name.length())
        buffer << name;

    for (uint32 i = 0; i < 3; ++i) // other 3 names
        buffer << uint16(0);

    std::string desc = proto->Description;
    if (locale >= 0)
        if (ItemLocale const* localeData = sObjectMgr->GetItemLocale(entry))
            ObjectMgr::GetLocaleStringOld(localeData->Description, locale, desc);

    buffer << uint16(desc.length());
    if (desc.length())
        buffer << desc;

    buffer << uint32(proto->PageText);
    buffer << uint32(proto->LanguageID);
    buffer << uint32(proto->PageMaterial);
    buffer << uint32(proto->StartQuest);
    buffer << uint32(proto->LockID);
    buffer << int32(proto->Material);
    buffer << uint32(proto->Sheath);
    buffer << int32(proto->RandomProperty);
    buffer << int32(proto->RandomSuffix);
    buffer << uint32(proto->ItemSet);

    buffer << uint32(proto->Area);
    buffer << uint32(proto->Map);
    buffer << uint32(proto->BagFamily);
    buffer << uint32(proto->TotemCategory);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SOCKETS; ++x)
        buffer << uint32(proto->Socket[x].Color);

    for (uint32 x = 0; x < MAX_ITEM_PROTO_SOCKETS; ++x)
        buffer << uint32(proto->Socket[x].Content);

    buffer << uint32(proto->socketBonus);
    buffer << uint32(proto->GemProperties);
    buffer << float(proto->ArmorDamageModifier);
    buffer << int32(proto->Duration);
    buffer << uint32(proto->ItemLimitCategory);
    buffer << uint32(proto->HolidayId);
    buffer << float(proto->StatScalingFactor);    // StatScalingFactor
    buffer << uint32(proto->CurrencySubstitutionId);
    buffer << uint32(proto->CurrencySubstitutionCount);
}

void WorldSession::HandleSetLootSpecialization(WorldPacket& recvData)
{
    TC_LOG_DEBUG("network", "WORLD: Received CMSG_SET_LOOT_SPECIALIZATION");

    uint32 lootSpecialization;
    recvData >> lootSpecialization;

    // If client sends 0 when setting to current specialization.
    if (lootSpecialization)
    {
        auto specializationEntry = sChrSpecializationStore.LookupEntry(lootSpecialization);
        if (!specializationEntry)
        {
            TC_LOG_DEBUG("network", "Player tried to set their loot specialization to %u which doesn't exist!", lootSpecialization);
            return;
        }

        if (GetPlayer()->GetClass() != specializationEntry->classId)
        {
            TC_LOG_DEBUG("network", "Player tried to set their loot specialization to %u which isn't valid for their class!", lootSpecialization);
            return;
        }
    }

    GetPlayer()->SetLootSpecialization(lootSpecialization);
}
